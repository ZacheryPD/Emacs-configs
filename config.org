#+TITLE: Emacs Configuration
* What is this?

  This literate file rep literate programming to make it easier to document the strange and arcane things that I sometimes have to do while learning more about Emacs. Hopefully this makes it easier to maintain and change in the future.
  
* Pre-configuration

  Before I actually configure anything interesting, I need to do  certain things (like install use-package). In this section, do not  assume that anything has been installed, but configure things that  are generic (at least in theory) to any configuration of Emacs.
  

** package.el

   First up, I have to make sure that [[https://repo.or.cz/w/emacs.git/blob_plain/HEAD:/lisp/emacs-lisp/package.el][package.el]] is configured. Package.el is a package manager that's built into GNU Emacs (apparently since Emacs24). I will be using `use-package` for the most part, but I will have to bootstrap that somehow and for now package.el (which is built in anywhere I have needed it) fits fine.
   

   #+BEGIN_SRC emacs-lisp
     (require 'package)
   #+END_SRC 

*** Package repositories

    By default, my Emacs distribution uses [[http://elpa.gnu.org/][ELPA]] , but I also want to use [[https://melpa.org/][MELPA]], so I will include that here.
    
    #+BEGIN_SRC emacs-lisp
      (add-to-list 'package-archives
		   '("melpa" . "https://melpa.org/packages/") t)
    #+END_SRC
*** Initialization

    To set up `package.el` I need to call `package-initialize`.
    
    #+BEGIN_SRC emacs-lisp
      (package-initialize)
    #+END_SRC

** Use-package

   Now that package.el is set up, I can finally install and use
   `use-package`! [[https://github.com/jwiegley/use-package/tree/a7422fb8ab1baee19adb2717b5b47b9c3812a84c#use-package][Use-package]] is a crazy macro that does a lot of
   things but I am primarily using it to lazy-load things (using
   `package.el`) and to consolidate the list of plugins I am using
   with their configuration. I am also using the installation of
   `use-package` as an indicator that this is the first run. I don't
   want to refresh packages every time I start up Emacs, that would
   take forever, so I am refreshing them if use-package is not already
   installed. If it isn't, then clearly my config hasn't been run
   before, so we should refresh package contents before doing the
   initial setup.

   #+BEGIN_SRC emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))
   #+END_SRC

   Also, when we are compiling packages, we want to make sure that
   use-package has been loaded.

   #+BEGIN_SRC emacs-lisp
     (eval-when-compile
       (require 'use-package))
   #+END_SRC

*** A brief introduction to use-package

Use package has a ton of options that I frequently forget how to use,
so I want to explain a few of them here for future reference. One of
the big benefits is that nothing is loaded by `use-package` until a
provided feature is actually requested. This means that you can defer
configuration easily!

**** Basic use-package and ensure

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package evil
    :ensure t)
#+END_SRC
When you include a package via `use-package` you simply specify the
name of the package. That will look at your load-path and try to find
a package that matches the name you've listed. This doesn't actually
install anything! It just looks at what is already installed and set
up on your load path. If you would like `use-package` to actually load
packages from your package archive(s) for you, you can provide the
`:ensure` option. By default this will cause it to load using
`package.el`, but I have heard that you can also use straight.el as
well.

**** Configuring things

In general, it's not a good idea to assume that a package is always
loaded. If you want to set things up only when a given package is
actually loaded, do your configuration in the `:config` section of
the use-package instance

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package evil
    :ensure t
    :config
    (format "Hello, world this should only show up when evil is actually loaded"))
#+END_SRC

You can also use the `:init` block if you want it to happen before the
package is loaded.

* Configuration

  This is where the meat-and-potatoes of my configuratoin will live.
  
** Utilities

*** Insert file name

   Inserts the current file name.
     #+BEGIN_SRC emacs-lisp
       (defun insert-file-name ()
	 "Insert the file name into the current buffer (at point)."
	 (interactive)
	 (insert (file-name-nondirectory
		  (buffer-file-name
		   (window-buffer
		    (minibuffer-selected-window))))))
   #+END_SRC

*** Yank current file name

    Pulls out the current file name

    #+BEGIN_SRC emacs-lisp
      (defun evil-yank-file-name ()
	"yank the file name associated with the current buffer."
	(interactive)
	(kill-new
	 (file-name-nondirectory
	   (buffer-file-name
	    (window-buffer
	     (minibuffer-selected-window))))))
    #+END_SRC

*** Switch to the scratch buffer

    #+BEGIN_SRC emacs-lisp
      (defun switch-to-scratch ()
	"Switches to the scratch buffer"
	(interactive)
	(switch-to-buffer "*scratch*"))
    #+END_SRC

*** Global auto revert

In most modern editors, when a file changes on disk, the editor warns
you or even automatically reads the file on disk! This is really
useful if you, for example, run a git pull, or have a file system sync
tool like Dropbox. This should enable just such a feature that is
built into most modern Emacs.

#+BEGIN_SRC emacs-lisp
  (setq auto-revert-check-vc-info t)
  (global-auto-revert-mode)
#+END_SRC 
** Local configuration

   This file is set up only so that you can set any local variables
   you might need.  For example, if you are loading on Windows you
   might need to set some file paths to your org files that are
   different from the defaults I have checked in. If this file exists
   (and it should be ignored in the Git repo) then Emacs will tangle
   and execute it just like this file. If not, it will ignore and
   continue. 

   #+BEGIN_SRC emacs-lisp
     (setq local-file-path "~/.emacs.d/local.org")
     (if (file-exists-p local-file-path)
	 (org-babel-load-file local-file-path))
   #+END_SRC

** Packages
*** Evil-mode

    Evil mode is the vim emulation layer.  I am using use-package to
    install and enable it. 
    
**** Evil itself

     #+BEGIN_SRC emacs-lisp
       (use-package evil
	 :ensure t
	 :init
	 (setq evil-want-keybinding nil)
	 (setq evil-want-C-u-scroll t)
	 :config
	 (evil-mode 1)

	 (evil-set-leader '(motion normal visual) (kbd "SPC"))
	 (evil-set-leader '(motion normal visual) (kbd "<leader> m") t)

	 (evil-global-set-key 'normal (kbd "<leader> SPC") 'execute-extended-command)

	 (evil-global-set-key 'normal (kbd "<leader> <tab>") 'previous-buffer)
	 (evil-global-set-key 'normal (kbd "<leader> <S-tab>") 'next-buffer) ; this works on Windows
	 (evil-global-set-key 'normal (kbd "<leader> <backtab>") 'next-buffer) ; this works on Linux
	 (evil-global-set-key 'normal (kbd "<leader> f s") 'save-buffer)
	 (evil-global-set-key 'normal (kbd "<leader> f S") 'evil-write-all)
	 (evil-global-set-key 'normal (kbd "<leader> f y") 'evil-yank-file-name)
	 (evil-global-set-key 'normal (kbd "<leader> l l") 'eval-last-sexp)
	 (evil-global-set-key 'normal (kbd "<leader> l L") 'eval-print-last-sexp)
	 (evil-global-set-key 'normal (kbd "<leader> l b") 'eval-buffer)
	 (evil-global-set-key 'normal (kbd "<leader> l r") 'eval-region)
	 (evil-global-set-key 'normal (kbd "<leader> w h") 'evil-window-left)
	 (evil-global-set-key 'normal (kbd "<leader> w j") 'evil-window-down)
	 (evil-global-set-key 'normal (kbd "<leader> w k") 'evil-window-up)
	 (evil-global-set-key 'normal (kbd "<leader> w l") 'evil-window-right)
	 (evil-global-set-key 'normal (kbd "<leader> w H") 'evil-window-move-far-left)
	 (evil-global-set-key 'normal (kbd "<leader> w J") 'evil-window-move-far-down)
	 (evil-global-set-key 'normal (kbd "<leader> w K") 'evil-window-move-far-up)
	 (evil-global-set-key 'normal (kbd "<leader> w L") 'evil-window-move-far-right)
	 (evil-global-set-key 'normal (kbd "<leader> w s") 'evil-window-split)
	 (evil-global-set-key 'normal (kbd "<leader> w v") 'evil-window-vsplit)
	 (evil-global-set-key 'normal (kbd "<leader> w d") 'evil-window-delete)
	 (evil-global-set-key 'normal (kbd "<leader> w o") 'other-window)
	 (evil-global-set-key 'normal (kbd "<leader> w m") 'delete-other-windows)
	 (evil-global-set-key 'normal (kbd "<leader> w f") 'make-frame)
	 (evil-global-set-key 'normal (kbd "<leader> b d") 'kill-buffer)
	 (evil-global-set-key 'normal (kbd "<leader> b s") 'switch-to-scratch)
	 (evil-global-set-key 'normal (kbd "<leader> q f") 'save-buffers-kill-terminal)
	 (evil-global-set-key 'normal (kbd "<leader> h f") 'describe-function)
	 (evil-global-set-key 'normal (kbd "<leader> h v") 'describe-variable)
	 (evil-global-set-key 'normal (kbd "<leader> h k") 'describe-key)
	 (evil-global-set-key 'normal (kbd "<leader> h n") 'view-emacs-news)
	 (evil-global-set-key 'normal (kbd "<leader> h m") 'describe-mode)
	 (evil-global-set-key 'normal (kbd "<leader> h i") 'info)
	 (evil-global-set-key 'normal (kbd "<leader> h M") 'view-order-manuals)
	 )
     #+END_SRC

**** Evil-collection

     We also want to use [[https://github.com/emacs-evil/evil-collection][`evil-collection`]] to set up things for
     "buffers evil mode doesn't think about by default"

     #+BEGIN_SRC emacs-lisp
       (use-package evil-collection
	 :after (evil magit)
	 :ensure t
	 :config
	 (evil-collection-init))
     #+END_SRC

**** Evil-surround

     Want to surround strings or expressions with things? This is how!

     #+BEGIN_SRC emacs-lisp
       (use-package evil-surround
	 :after evil
	 :ensure t
	 :config (global-evil-surround-mode))
     #+END_SRC

**** Evil-cleverparens

     [[https://github.com/luxbock/evil-cleverparens][This package]] is really helpful generally for writing Elisp. It
     has a bunch of features but it shold auto-close parens, and
     generally make evil mode actions aware of the syntax of lisp.

     #+BEGIN_SRC emacs-lisp
       (use-package evil-cleverparens
	 :after evil
	 :ensure t
	 :hook ( emacs-lisp-mode . evil-cleverparens-mode ))

     #+END_SRC

**** TODO Undo-tree

     Undo tree is a huge plugin whose features I am probably not using
     properly. For now I am using it only because undo functionality
     in Emacs 27 w/ Evil seems to need it. I should spend some time
     investigating features. Also, once I switch to Emacs 28, I may be
     able to use a native option.
     
     #+BEGIN_SRC emacs-lisp
       (use-package undo-tree
	 :ensure t
	 :after evil
	 :diminish
	 :config
	 (evil-set-undo-system 'undo-tree)
	 (setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo")))
	 (global-undo-tree-mode 1))
     #+END_SRC
*** Company-mode

    [[http://company-mode.github.io/][Company mode]] is an auto complete plugin (*comp*-lete
    *any*-thing). I am still exploring how it can be used.
     #+BEGIN_SRC emacs-lisp
       (use-package company
	 :ensure t
	 :hook (prog-mode . company-mode)
	 :config
	 (setq company-idle-delay 0)
	 (setq company-minimum-prefix-length 1)
	 (setq company-selection-wrap-around t)
	 (company-tng-configure-default))
    #+END_SRC
*** Spacemacs theme

    I like the Spacemacs theme quite a lot, so I'll use it.

    #+BEGIN_SRC emacs-lisp
      (use-package spacemacs-theme
	:ensure t
	:defer t
	:init (load-theme 'spacemacs-dark t))
    #+END_SRC

*** Which key mode

    Which key is a pannel at the bottom that should display options
    when a key is pressed.

    #+BEGIN_SRC emacs-lisp
      (use-package which-key
	:ensure t
	:config
	(which-key-mode))
    #+END_SRC
*** IDO-mode

    IDO mode is a completion engine. There are two other primary
    engines that people use: [[https://emacs-helm.github.io/helm/][Heml]] and [[https://github.com/abo-abo/swiper][Ivy]]. I'm not really sure what
    the advantages of either are, but Mastering Emacs suggests IDO. I
    have used Helm in Spacemacs before, so I may later switch to that.

    #+BEGIN_SRC emacs-lisp
      (use-package ido
	:ensure t
	:after evil
	:config
	(setq ido-enable-flex-matching t)
	(setq ido-everywhere t)
	(ido-mode 1)
	(setq ido-use-filename-at-point 'guess)
	:config
	(evil-global-set-key 'normal (kbd "<leader> f f") 'ido-find-file)
	(evil-global-set-key 'normal (kbd "<leader> b b") 'ido-switch-buffer)
	(evil-global-set-key 'normal (kbd "<leader> f d") 'ido-dired))
    #+END_SRC

**** Vertical display

    Also, I dislike that ido mode organizes itself horizontally, and
    want it to not do that.

    #+BEGIN_SRC emacs-lisp
      (use-package ido-vertical-mode
	:ensure t
	:after ido
	:config
	(ido-vertical-mode 1))
    #+END_SRC

**** Priority

     It annoys me that when I am editing projects that contain files
     of the same name but with differing extensions, that IDO doesn't
     know which one I usually want. This should make sure that when I
     am editing files, IDO prefers ~.org~ files to ~.el~ files.

     #+BEGIN_SRC emacs-lisp
       (setq ido-file-extensions-order '(".org" ".el"))
     #+END_SRC

     
**** Ido-completing-read+

    #+BEGIN_SRC emacs-lisp
      (use-package ido-completing-read+
	:ensure t
	:config
	(ido-ubiquitous-mode 1))
    #+END_SRC
*** Magit

    I love [[https://magit.vc/][Magit]]. Enough said.

    #+BEGIN_SRC emacs-lisp
      (use-package magit
	:ensure t
	:after evil
	:config
	(evil-global-set-key 'normal (kbd "<leader> g s") 'magit-status))
    #+END_SRC
*** Org mode
**** Various org mode configuration
:PROPERTIES:
:header-args: :noweb-ref org-variables-config
:END:
      
***** Variable tweaks for Org mode

There are a ton of options for org mode and I only use a very small number of them. Here I attempt to organize my config into subsections that can be tangled elsewhere using ~noweb~.

Notice the properties on this header. It means that all the source blocks below this header will have that name, so we can reference them all at once. 

******* Set up org agenda files

      Note, you will probably want to override these variables in your
      local config.
      
      #+BEGIN_SRC emacs-lisp :tangle no
	(defvar org-directory nil) ; Set this in your local.org file!
	(defvar org-jira-link "") ; Set this in your local.org file!
      #+END_SRC

      First up, I need to define what my org mode agenda files
      are. I'm going to wind up using these all over the place, so I
      am going to define them all together

      #+BEGIN_SRC emacs-lisp :tangle no
	(setq todo-org "todo.org")
	(setq professional-org "professional.org")
	(setq personal-org "personal.org")
	(setq school-org "school.org")
	(setq notes-org "notes.org")
	(setq inbox-org "inbox.org")
	(setq project-org "project.org")
	(setq reviews-org "reviews.org")
	(setq meetings-org "meetings.org")
	(setq interruption-org "interruption.org")
	(setq contact-log-org "contact-log.org")
	(setq one_on_one_topics-org "one-on-one-topics.org")
      #+END_SRC
      
      Once I have those variables, I am going to want to concatenate
      the path to my org files to them. To enable that, we should
      write a handly little method
      
      #+BEGIN_SRC emacs-lisp :tangle no
	(defun org-concat-org-directory (fileName)
	  (concat org-directory fileName))
      #+END_SRC
      
      #+BEGIN_SRC emacs-lisp :tangle no
	(defun setup-org-agenda-files ()
	  (add-to-list 'org-agenda-files (org-concat-org-directory todo-org))
	  (add-to-list 'org-agenda-files (org-concat-org-directory professional-org))
	  (add-to-list 'org-agenda-files (org-concat-org-directory personal-org))
	  (add-to-list 'org-agenda-files (org-concat-org-directory school-org))
	  (add-to-list 'org-agenda-files (org-concat-org-directory notes-org))
	  (add-to-list 'org-agenda-files (org-concat-org-directory inbox-org))
	  (add-to-list 'org-agenda-files (org-concat-org-directory project-org))
	  (add-to-list 'org-agenda-files (org-concat-org-directory meetings-org))
	  (add-to-list 'org-agenda-files (org-concat-org-directory interruption-org))
	  (add-to-list 'org-agenda-files (org-concat-org-directory contact-log-org)))
      #+END_SRC

The I have a number of files defined elsewhere. This function should take all those file names and append them into whatever org-directory the system has set up.

#+BEGIN_SRC emacs-lisp :tangle no
  (setup-org-agenda-files)
#+END_SRC

******* Configure capture templates

      In this section, I define a bunch of lists that represent
      capture templates. Normally, one would have one large list that
      gets assigned to ~org-capture-templates~, but I have many
      templates for many situations, so I'd like to break them apart
      and document each one individually.  To do that requires some
      subtletly, though, because a capture template needs to be in a
      form like this:

      #+BEGIN_SRC emacs-lisp :tangle no 
	`("t" ; A "key" to use as a hotkey in the template selection UI
	  "Todo" ; A description for the template
	  entry ; A type, usually entry
	  (file ,(concat org-directory inbox-org)) ; A function that takes
						   ; some input, which must
						   ; resolve to a string, so
						   ; it must be interpreted!
	  "* TODO %?\n  %i\n  %a") ; An actual template string
      #+END_SRC

      This is important, because putting a function call in the ~(file
      (concat ...))~ line will cause things to not evaluate correctly,
      so we have to make use of [[*Backtick and comma notation][backtick and comma notation]].

******** Todo template

       This template is just a simple TODO template that drops things
       in my inbox file.

       #+BEGIN_SRC emacs-lisp :tangle no
	 (setq org-todo-capture-template
	       `("t"
		 "Todo"
		 entry
		 (file ,(concat org-directory inbox-org))
		 "* TODO %?\n  %i\n  %a"))
       #+END_SRC
       
******** Interruption template

       This template is to note times that I am interrupted by
       something unexpected. I mostly use these entries to track time
       and see where I am getting interrupted at work.

       #+BEGIN_SRC emacs-lisp :tangle no
	 (setq org-interruption-capture-template
	       `("i"
		 "interruption"
		 entry
		 (file+datetree ,(concat org-directory interruption-org))
		 "* Interrupted by %?\n%t"))
       #+END_SRC
       
******** Note template

       All of my notes start off as "notes to self" in my notes
       file. I regularly prune that section to store things that I
       want to reference in more permanent locations. This is
       basically a separate inbox just for my notes. I may in the
       future just redirect this to drop things right in my normal
       inbox file.

       #+BEGIN_SRC emacs-lisp :tangle no
	 (setq org-note-capture-template
	       `("n"
		 "Note to self"
		 entry
		 (file+headline ,(concat org-directory notes-org) "Note to Self")
		 "* %?\nEntered on %U\n  %i\n  %a"))
       #+END_SRC

******** Contact template

       The contact template helps me track important interractions
       that I have.  I use this file sort of like a personal CRM so
       that I can easily check in on whether or not I know someone or
       what my last meaningful interaction with them was. I only use
       this for professional contact.

       #+BEGIN_SRC emacs-lisp :tangle no
	 (setq org-contact-capture-template
	       `("c"
		 "contact"
		 entry
		 (file+datetree ,(concat org-directory contact-log-org))
		 "* Contacted by: %\\1%?
						   :PROPERTIES:
						   :NAME:       %^{Name}
						   :COMPANY:    %^{Company}
						   :HEADHUNTER: %^{Headhunter|Y|N}
						   :SOURCE:     %^{Source|LinedIn|Phone|Email}
						   :END:"))
       #+END_SRC

******** One on one template
     
       I have regular one on one meetings with people, both as a
       mentor and to get mentoring. As such, I often need to keep
       track of a list of topics to discuss with different people on a
       given week. This template generates a note in a "weekly
       datetree" for each of those conversations.

       #+BEGIN_SRC emacs-lisp :tangle no
	  (setq org-one-on-one-capture-template
		`("wo"
		  "one on one topics"
		  plain ; also unsure what plain actually means
		  (file+function ,(concat org-directory one_on_one_topics-org) org-week-datetree)
		 "*** %?")) ; note the 3 asterisks.  Would be nice to figure out how to do that without but eh.
       #+END_SRC

******** Query template

       I write a lot of SQL queries.  Sometimes this is a migration to
       set up data for a new enhancement, and sometimes it's a one-off
       query to help investigate something. This template asks for a
       DB to run against, a ticket (like Jira), and a type (which is a
       flexible field that could mean anything) and saves it in my
       inbox so I can archive it for reference later.

       #+BEGIN_SRC emacs-lisp :tangle no
	  (setq org-query-capture-template
		`("wQ"
		  "Datebase Query"
		  entry
		  (file ,(concat org-directory inbox-org))
		  "* %\\2%?
					  :PROPERTIES:
					  :DATABASE: %^{database|STATIC_TABLES|TENANTS}
					  :TICKET:   %^{ticket}
					  :TYPE:     %^{type|DATA|POST_MIGRATION}
					  :END:
					  ,#+BEGIN_SRC sql :tangle %\\2-%\\1-%\\3.txt
					  ,#+END_SRC
					  "))
       #+END_SRC

******** Jira ticket

       I work on projects that use Jira a lot, so often I find myself
       wanting to keep track of a ticket. Jira boards are nice, but my
       agenda with all my other tasks is nicer. This template will
       format a nice entry in my todo list with a link to your Jira
       instance.  Just make sure ~org-jira-link~ is set prior to
       running this template.

       #+BEGIN_SRC emacs-lisp :tangle no
	  (setq org-jira-ticket-capture-template
		`("wj"
		 "Jira ticket"
		 entry
		 (file ,(concat org-directory inbox-org))
		 ,(concat "* TODO %\\1%?
					  [[" org-jira-link "%^{ticket}][%\\1]]")))
       #+END_SRC

******** Meeting capture template

       I am in a lot of meetings. I also often fail to remember
       things. this capture template will create a new entry in the
       meetings file under the given day (in a date tree) to make it
       easier for me to find meetings if I know about when they
       happened.

       #+BEGIN_SRC emacs-lisp :tangle no
	  (setq org-meeting-minute-capture-template
		`("wm"
		  "Meeting notes"
		  entry
		  (file+datetree ,(concat org-directory meetings-org))
		  "* %?\n%U\n"))
       #+END_SRC

******* Set capture templates

Org has a system called "[[https://orgmode.org/manual/Using-capture.html][capture]]" data from wherever you are. You can fire that off using ~org-capture~. I have set up capture templates elsewhere and this line should combine all my capture templates into the final list that Emacs actually reads from.

You can also group templates behind prefixes. I do this with "work" specific templates. Templates that are specific to "work" are hidden behind ~w~ which has its own description as seen below.

#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-capture-templates
	`(,org-todo-capture-template 
	  ,org-note-capture-template
	  ,org-interruption-capture-template
	  ,org-contact-capture-template 
	  ("w" "Templates around office/work stuff")
	  ,org-one-on-one-capture-template
	  ,org-query-capture-template 
	  ,org-jira-ticket-capture-template
	  ,org-meeting-minute-capture-template))
#+END_SRC

******* Agenda config

I happen to like seeing two weeks at once in my agenda. This line should make that the default view.

#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-agenda-span 14)
#+END_SRC

This changes the [[https://orgmode.org/manual/Refile-and-Copy.html][refile]] targets. Refile is a tool for re-organizing org mode files. In my case, I want to be able to refile to files and not just org headers. This should make that possible!

#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-refile-targets (quote ((nil :maxlevel . 5)
				   (org-agenda-files :maxlevel . 5))))
#+END_SRC

This change should make it so that the UI that displays "where" you are in a org heading tree shows as a file path. So if you have a doc that contains a header called Heading 1 and a subheading called Subheading 1, if you are refiling into Subheading 1 you will see Heading 1/Subheading 1 in the refile auto-complete.

#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-refile-use-outline-path 'file)
#+END_SRC

******* Drawer config

Sets the org-repeat logbook to store its information in the "LOGBOOK" drawer instead of in a bulleted list on the header. this should keep things cleaner. I was having issues with beorg putting things in some places and emacs putting them in others, so for now I am just putting it all in here.
#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-log-into-drawer "LOGBOOK")
#+END_SRC
******* Task keywords

You can set what states are valid for tasks in org files globally. I do sometimes override this on a per-file basis as it's appropriate, so I don't have many states set up here.

#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-todo-keywords
	'((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)" "CANCELED(c)")))
#+END_SRC
******* org-log

I have had some issues with different apps logging repeating tasks and I don't usually care about tracking it, so this should just disable that for now.


#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-log-repeat nil)
#+END_SRC

***** Org datetree functions

      I have two custom date-tree functions that I wrote to make
      capture templates easier to work with. These were based on [[https://emacs.stackexchange.com/questions/48414/monthly-date-tree][this]].
      
      First up, this tree is a "datetree" only to the month.
      #+BEGIN_SRC emacs-lisp :tangle no
	(defun org-month-datetree()
	  (org-datetree-find-date-create (calendar-current-date))
	  ;; Kill the line because this date tree will involve a subheading for the week
	  (kill-line))
      #+END_SRC
      
      Next up, a date tree th a week
      #+BEGIN_SRC emacs-lisp :tangle no
	(defun org-week-datetree()
	  (org-datetree-find-iso-week-create (calendar-current-date))
	  ;; Kill the line because this date tree will involve a subheading for the day
	  (kill-line))
      #+END_SRC

***** inserting blocks

I borrowed this [[https://www.handsonprogramming.io/blog/2021/12/source-block/][from a blog post]] and adapted it for my needs.

#+BEGIN_SRC emacs-lisp :tangle no
  (defun org-insert-src-block (src-code-type)
    "Insert a `SRC-CODE-TYPE' type source code block in org-mode."
    (interactive
     (let ((src-code-types
	    '(
	      "emacs-lisp"
	      "python"
	      "C"
	      "sh"
	      "js" 
	      "sql" 
	      "latex"
	      "lisp"
	      "org" 
	      "scheme" )))
       (list (ido-completing-read "Source code type: " src-code-types))))
    (progn
      (newline-and-indent)
      (insert (format "#+BEGIN_SRC %s\n" src-code-type))
      (newline-and-indent)
      (insert "#+END_SRC\n")
      (previous-line 2)
      (org-edit-src-code)))
#+END_SRC

**** Require package

    #+BEGIN_SRC emacs-lisp :noweb yes
      (use-package org
	:ensure t
	:config
	<<org-variables-config>>
	(evil-define-key 'normal org-mode-map (kbd "<localleader> d s") 'org-schedule)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> d d") 'org-deadline)

	(evil-define-key 'normal org-mode-map (kbd "<localleader> s r") 'org-refile)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> s n") 'org-narrow-to-subtree)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> s a") 'org-archive-subtree-default)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> s w") 'widen)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> s h") 'org-promote)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> s l") 'org-demote)

	(evil-define-key 'normal org-mode-map (kbd "<localleader> p") 'org-priority)

	(evil-define-key 'normal org-mode-map (kbd "<localleader> C i") 'org-clock-in)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> C o") 'org-clock-out)

	(evil-define-key 'normal org-mode-map (kbd "<localleader> T T") 'org-todo)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> b t") 'org-babel-tangle)

	(evil-define-key 'normal org-mode-map (kbd "<localleader> i l") 'org-insert-link)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> i i") 'org-insert-item)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> i t") 'org-set-tags-command)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> i T t") 'org-table-create)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> i T r") 'org-table-insert-row)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> i T c") 'org-table-insert-column)
	(evil-define-key 'normal org-mode-map (kbd "<localleader> i s") 'org-insert-src-block)

	(evil-define-key 'normal org-mode-map (kbd "<localleader> <return>") 'org-open-at-point)

	(evil-define-key 'edit 'org-mode-map (kbd "<M-return>") 'org-insert-item)

	(evil-global-set-key 'normal (kbd "<leader> a o a") 'org-agenda)
	(evil-global-set-key 'normal (kbd "<leader> a o c") 'org-capture))
    #+END_SRC

**** evil-org

     #+BEGIN_SRC emacs-lisp
       (use-package evil-org
	 :ensure t
	 :after org
	 :hook (org-mode . (lambda () evil-org-mode))
	 :config
	 (require 'evil-org-agenda)
	 (evil-org-agenda-set-keys))
     #+END_SRC

**** Org bullets

     A really cool plugin that makes pretty bullets

     #+BEGIN_SRC emacs-lisp
       (use-package org-bullets
	 :after org
	 :ensure t
	 :config
	 (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
     #+END_SRC

**** org-ql 

[[https://github.com/alphapapa/org-ql][Org-ql]], similar to the older [[https://github.com/alphapapa/org-rifle][org-rifle]],is a plugin for searching your
org headers/body. I primarily just use it to find tasks/notes in
either my org-directory or in my agenda (a smaller list).

#+BEGIN_SRC emacs-lisp
  (use-package org-ql
    :ensure t
    :config
    (evil-global-set-key 'normal (kbd "<leader> a o s d") 'org-ql-find-in-org-directory)
    (evil-global-set-key 'normal (kbd "<leader> a o s a") 'org-ql-find-in-agenda)
    (evil-global-set-key 'normal (kbd "<leader> a o s f") 'org-ql-find))
#+END_SRC

**** org-pomodoro

[[https://github.com/marcinkoziej/org-pomodoro][Org pomodoro]] is a tool for doing the [[https://en.wikipedia.org/wiki/Pomodoro_Technique][pomodoro technique]] in Emacs org mode.


#+BEGIN_SRC emacs-lisp
  (use-package org-pomodoro
    :ensure t
    :after org
    :config
    (evil-define-key 'normal org-mode-map (kbd "<localleader> C p") 'org-pomodoro)
    (evil-define-key 'motion org-agenda-mode-map (kbd "c p") 'org-pomodoro))

#+END_SRC

*** Editorconfig
    
    Editorconfig is a standard for keeping code editing settings in
    sync across tools and teams.  Someone can check in a .Editorconfig
    file at the root of a repo, and their editors should respect the
    settings. This should do that for me!

    #+BEGIN_SRC emacs-lisp
      (use-package editorconfig
	:ensure t
	:config
	(editorconfig-mode 1))
    #+END_SRC
*** Smartparens

    #+BEGIN_SRC emacs-lisp
      (use-package smartparens
	:ensure t
	:hook ( emacs-lisp-mode . smartparens-mode))
    #+END_SRC
*** Web mode

    #+BEGIN_SRC emacs-lisp
      (use-package web-mode
	:ensure t
	:config
	(add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
	(add-to-list 'auto-mode-alist '("\\.php\\'" . web-mode))
	(evil-define-key 'normal web-mode-map (kbd "<localleader> <tab>") 'web-mode-fold-or-unfold)
	(evil-define-key 'normal web-mode-map (kbd "<localleader> i l") 'web-mode-file-link)
	(evil-define-key 'normal web-mode-map (kbd "<localleader> g t") 'web-mode-navigate)
	(evil-define-key 'normal web-mode-map (kbd "<localleader> g j") 'web-mode-tag-next)
	(evil-define-key 'normal web-mode-map (kbd "<localleader> g k") 'web-mode-tag-previous))
    #+END_SRC
*** Zettelkasten

    This is a plugin that isn't in MELPA for now, and I can't seem to
    convince it to load by adding it to ~load-path~ so I am instead
    going to manually require it.
    #+BEGIN_SRC emacs-lisp
      (require 'zettelkasten-mode "~/.emacs.d/plugins/zettelkasten/zettelkasten.el")
    #+END_SRC

    To actually configure it, though, I still want to use
    ~use-package~, so now that it's loaded, I can use ~use-package~ to
    activate it and set up the basic keybindings. Yay, some consistency!
    
    #+BEGIN_SRC emacs-lisp
      (use-package zettelkasten-mode
	:bind
	(:map evil-normal-state-map
	      ("SPC a z c" . 'zettel-create-new)
	      ("SPC a z i" . 'zettel-insert-and-create-new))
	:config
	(zettelkasten-mode 1))
    #+END_SRC
*** Markdown-mode

    I use Markdown for quite a lot, so I need a markdown mode. This
    one could probably be configured more.

    #+BEGIN_SRC emacs-lisp
      (use-package markdown-mode
	:ensure t
	:config
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> <return>") 'markdown-do)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> g f") 'markdown-outline-next-same-level)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> g b") 'markdown-outline-previous-same-level)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> g n") 'markdown-outline-next)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> g p") 'markdown-outline-previous)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> g u") 'markdown-outline-up)

	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i f") 'markdown-insert-footnote)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i w") 'markdown-insert-wiki-link)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i i") 'markdown-insert-image)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i l") 'markdown-insert-link)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i H") 'markdown-insert-hr)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i h 1") 'markdown-insert-header-atx-1)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i h 2") 'markdown-insert-header-atx-2)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i h 3") 'markdown-insert-header-atx-3)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i t t") 'markdown-insert-table)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i t r") 'markdown-table-insert-row)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> i t c") 'markdown-table-insert-column)

	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> s h") 'markdown-promote)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> s l") 'markdown-demote)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> S h") 'markdown-toggle-markup-hiding)

	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> p") 'markdown-live-preview-mode)

	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> e e") 'markdown-export)
	(evil-define-key 'normal markdown-mode-map (kbd "<localleader> e p") 'markdown-export-and-preview)
	(markdown-toggle-markup-hiding 1))
    #+END_SRC
*** Python mode

    #+BEGIN_SRC emacs-lisp
      (use-package python-mode
	:ensure t)
    #+END_SRC
*** Vue mode

    I need a major mode for Vue files!

    #+BEGIN_SRC emacs-lisp
      (use-package vue-mode
	:ensure t)
    #+END_SRC
*** Tab bar mode

    This should enable a tab bar. This is built into emacs as of 27, I
    think. Each tab is a configuration of windows, so the splits and
    whatnot should be maintained?

    #+BEGIN_SRC emacs-lisp
      (use-package tab-bar
	:bind
	(:map evil-normal-state-map
	      ("<leader> C-t" . 'tab-new)
	      ("<leader> <C-tab>" . 'tab-next)
	      ("<leader> <C-S-tab>" . 'tab-previous)
	      ("<leader> <C-backtab>" . 'tab-previous)
	      ("<leader> C-w" . 'tab-close)))
    #+END_SRC
*** Powershell mode

    #+BEGIN_SRC emacs-lisp
      (use-package powershell
	:ensure t)
    #+END_SRC 
*** Dockerfiles

    #+BEGIN_SRC emacs-lisp
      (use-package dockerfile-mode
	:ensure t)
    #+END_SRC
*** TODO Typescript mode

    #+BEGIN_SRC emacs-lisp
      (use-package typescript-mode
	:ensure t)

      (use-package tide
	:after (typescript-mode company flycheck)
	:ensure t
	:config
	(evil-define-key 'normal tide-mode-map (kbd "<localleader> g d") 'tide-jump-to-definition)
	(evil-define-key 'normal tide-mode-map (kbd "<localleader> r .") 'tide-refactor)
	(evil-define-key 'normal tide-mode-map (kbd "<localleader> r r") 'tide-rename-symbol)
	:hook
	((before-save . tide-format-before-save)
	 (typescript-mode . tide-setup)))

    #+END_SRC
*** TODO Flycheck mode

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t)
#+END_SRC
*** LSP-mode

    #+BEGIN_SRC emacs-lisp
      (use-package lsp-mode
	:after evil
	:ensure t
	:config
	(evil-define-key 'normal lsp-mode-map (kbd "<localleader>") lsp-command-map)
	:hook ((csharp-mode . lsp-mode)
	       (lsp-mode . lsp-enable-which-key-integration))
	:commands lsp)
    #+END_SRC
*** Csharp mode

    #+BEGIN_SRC emacs-lisp
      (use-package csharp-mode
	:ensure t)
    #+END_SRC

*** Treemacs

    
**** Treemacs itself

     #+BEGIN_SRC emacs-lisp
       (use-package treemacs
	 :ensure t
	 :defer t
	 :config
	 (progn
	   ;; The default width and height of the icons is 22 pixels. If you are
	   ;; using a Hi-DPI display, uncomment this to double the icon size.
	   ;; (treemacs-resize-icons 44)

	   (treemacs-follow-mode t)
	   (treemacs-filewatch-mode t)
	   (treemacs-fringe-indicator-mode 'always)

	   (pcase (cons (not (null (executable-find "git")))
			(not (null treemacs-python-executable)))
	     (`(t . t)
	      (treemacs-git-mode 'deferred))
	     (`(t . _)
	      (treemacs-git-mode 'simple)))

	   (treemacs-hide-gitignored-files-mode nil))
	 :bind
	 (:map evil-normal-state-map 
	       ("SPC p t"   . treemacs)))

       (use-package treemacs-evil
	 :after (treemacs evil)
	 :ensure t)

       (use-package treemacs-icons-dired
	 :hook (dired-mode . treemacs-icons-dired-enable-once)
	 :ensure t)

       (use-package treemacs-magit
	 :after (treemacs magit)
	 :ensure t)

       (use-package treemacs-tab-bar ;;treemacs-tab-bar if you use tab-bar-mode
	 :after (treemacs)
	 :ensure t
	 :config (treemacs-set-scope-type 'Tabs))
     #+END_SRC

*** project.el
I need a convenient way to remember "the current project"
#+BEGIN_SRC emacs-lisp
  (defun project-remember-current ()
    (interactive)
    (project-remember-project (project-current)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package project
    :bind
    (:map evil-normal-state-map
	  ("<leader> p r" . 'project-remember-current)
	  ("<leader> p s" . 'project-switch-project)
	  ("<leader> p b" . 'project-switch-to-buffer)
	  ("<leader> p f" . 'project-find-file)
	  ("<leader> p d" . 'project-dired)
	  ("<leader> p !" . 'project-shell-command)))

#+END_SRC

*** Flyspell mode

#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :ensure t
    :hook
    ((prog-mode . flyspell-prog-mode)
     (text-mode . flyspell-mode))
    :config
    (evil-global-set-key 'normal (kbd "<leader> s c") 'flyspell-correct-word-before-point)
    (evil-global-set-key 'normal (kbd "<leader> s b") 'flyspell-buffer))
#+END_SRC

*** Visual fill column 

This minor mode allows me to softly (without inserting a new line)
wrap lines. I mostly use this when writing markdown notes so that they
look decent on my mobile devices.

#+BEGIN_SRC emacs-lisp
  (use-package visual-fill-column
    :ensure t
    :hook (visual-line-mode . visual-fill-column-mode))
#+END_SRC

This uses visual line mode, which is built into emacs itself. That
said I would like it to turn on in org-mode and in markdown-mode.

#+BEGIN_SRC emacs-lisp
  (use-package visual-line-mode
    :hook (text-mode . visual-line-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package adaptive-wrap
    :ensure t
    :hook (text-mode . adaptive-wrap-prefix-mode))
#+END_SRC
** Backups

    Emacs keeps backups of files that you have open in case something
    bad happens and they need to be recovered. They're stored in the
    same directory as the file you are working on by default, and end
    in a "~". I find all these extra files pretty bothersome, but I
    similar to what I do with undo-tree, I want to store them in a
    central location. Stolen from [[https://stackoverflow.com/questions/2680389/how-to-remove-all-files-ending-with-made-by-emacs][Stack Overflow]].

   #+BEGIN_SRC emacs-lisp
     (setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backup/")))
       backup-by-copying t    ; Don't delink hardlinks
       version-control t      ; Use version numbers on backups
       delete-old-versions t  ; Automatically delete excess backups
       kept-new-versions 20   ; how many of the newest versions to keep
       kept-old-versions 5    ; and how many of the old
       )
   #+END_SRC

   There is also an "autosave" functionality that saves files every
   few minutes in case of a crash. These files are usually dropped
   inline just like the backup files, but they are usually named
   #filename#. This is super useful, but also junks up git repos, etc,
   so lets store them in our .emacs.d as well.
   
   #+BEGIN_SRC emacs-lisp
     (setq auto-save-file-name-transforms
	   `((".*" ,(concat user-emacs-directory "saves/") t)))
   #+END_SRC

** Visual changes

I like being able to see when I am looking at the first or last line
in a buffer. This should show that in the margin around the buffer.

#+BEGIN_SRC emacs-lisp
  (setq-default indicate-buffer-boundaries 'left)
#+END_SRC

I also don't like the cursor blinking like a terminal from the 60s

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode -1)
#+END_SRC

I also like having the line the cursor is currently on hilighted a
different color to make it easier to see. I have this turned on only
for things that inherit ~prog-mode~ because it helps keep the line
highlighting when writing prose.

#+BEGIN_SRC emacs-lisp
  (let ((hl-line-hooks '(text-mode-hook prog-mode-hook)))
    (mapc (lambda (hook) (add-hook hook 'hl-line-mode)) hl-line-hooks))
#+END_SRC

*** Fonts

Fonts are a complicated topic and I expect this section to change
quite a lot.  I happen to really like the Spacemacs font
(SourceCodePro) which is an adobe font.

#+BEGIN_SRC  emacs-lisp
  (set-frame-font "Source Code Pro 12" nil t)
#+END_SRC

* Sources

  + [[https://masteringemacs.org/article/beginners-guide-to-emacs][Mastering Emacs Beginners Guide]]
  + [[https://git.sr.ht/~ashton314/emacs-bedrock][Emacs Bedrock]]
* Notes
** Backtick and comma notation

   Normally when initializing a list, one would use the form:

   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar my-list '(a b c))
   #+END_SRC

   Which is really just a shortcut for:

   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar my-list (list a b c))
   #+END_SRC

   This is all well and good, until you need to do something that
   would require you to not pass a variable, such as in a macro.  For
   example:
   

   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar foo 'asdf)
     (defvar my-list '(a b c foo))
   #+END_SRC

   isn't going to have the effect you want (having the atom ~asdf~ in
   your list). In this case, you can use the backtick (`) in place of
   the quote. It's functionally equivalent to the quote form, except
   it will cause expressions preceded with a comma to be evaluated for
   their result. So instead of the above, you could do:

   #+BEGIN_SRC emacs-lisp :tangle no
     (defvar foo 'asdf)
     (defvar my-list `(a b c ,foo))
   #+END_SRC

   Which will give you the expected result.
   
** Scratch ERT space

    I just discovered ERT so I added a simple example.
   #+BEGIN_SRC emacs-lisp
     (ert-deftest testing-ert ()
       "This is a test"
       (should (equal 1 1)))
   #+END_SRC
